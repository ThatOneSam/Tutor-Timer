plugins {
	id 'java'
	id 'jacoco'
}

repositories {
	mavenLocal()
	maven {
		url = 'https://repo.runelite.net'
		content {
			includeGroupByRegex("net\\.runelite.*")
		}
	}
	mavenCentral()
}

def runeLiteVersion = 'latest.release'
def pluginMainClass = 'com.tutortimer.TutorTimerPluginTest'

dependencies {
	compileOnly group: 'net.runelite', name:'client', version: runeLiteVersion

	compileOnly 'org.projectlombok:lombok:1.18.30'
	annotationProcessor 'org.projectlombok:lombok:1.18.30'

	testImplementation 'junit:junit:4.12'
	testImplementation 'org.mockito:mockito-core:5.11.0'
	testImplementation group: 'net.runelite', name:'client', version: runeLiteVersion
	testImplementation group: 'net.runelite', name:'jshell', version: runeLiteVersion
}

group = 'com.tutortimer'
version = '1.0.0'

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8'
	options.release.set(11)
}

test {
	useJUnit()
	finalizedBy jacocoTestReport
}

jacocoTestReport {
	dependsOn test
	reports {
		xml.required = true
		csv.required = false
		html.required = true
	}
}

tasks.register('run', JavaExec) {
	classpath = sourceSets.test.runtimeClasspath
	mainClass = pluginMainClass

	jvmArgs "-ea"
	args "--developer-mode", "--debug"

	// Use a test-specific Logback config so stdout only contains our plugin logs
	systemProperty 'logback.configurationFile', file('src/test/resources/logback-run-filtered.xml').absolutePath

	// Write the client stdout/stderr to a file so we can inspect runtime logs easily
	def runLog = file("${buildDir}/run.log")
	doFirst {
		runLog.parentFile?.mkdirs()
	}

	// Keep the stream in a local variable so we can close it in doLast
	def runOut = new FileOutputStream(runLog, true)
	standardOutput = runOut
	errorOutput = runOut
	doLast {
		try {
			runOut.flush()
			runOut.close()
		} catch (Exception ignored) {
		}
	}
}

// Helpful tasks for dealing with a locked run.log during development
// `clearRunLog` - attempts to delete build/run.log (retries, non-fatal)
// `forceClean`  - removes everything under build/ except run.log so `clean`-style builds succeed

tasks.register('clearRunLog') {
	group = 'build'
	description = 'Attempt to delete build/run.log (retries and warns if locked)'
	doLast {
		def runLog = file("${buildDir}/run.log")
		if (!runLog.exists()) {
			println "No run.log present"
			return
		}

		int attempts = 5
		boolean deleted = false
		for (int i = 1; i <= attempts; i++) {
			try {
				if (runLog.delete()) {
					println "Deleted build/run.log"
					deleted = true
					break
				}
				println "Attempt ${i}: could not delete run.log (may be locked)"
			} catch (Exception e) {
				println "Attempt ${i}: exception deleting run.log: ${e.message}"
			}
			Thread.sleep(500)
		}

		if (!deleted) {
			println "Could not delete build/run.log - it may be locked by another process. Close processes that use the file (IDE/Gradle/RuneLite) or reboot."
		}
	}
}

tasks.register('forceClean') {
	group = 'build'
	description = 'Delete build/* except build/run.log (use when run.log is locked)'
	doLast {
		if (!buildDir.exists()) {
			println "build/ does not exist"
			return
		}

		buildDir.eachFile { f ->
			if (f.name == 'run.log') {
				println "Skipping build/run.log (may be locked)"
				return
			}
			try {
				project.delete(f)
				println "Deleted ${f.name}"
			} catch (Exception e) {
				println "Failed to delete ${f.name}: ${e.message}"
			}
		}
	}
}

tasks.register('shadowJar', Jar) {
	dependsOn configurations.testRuntimeClasspath
	manifest {
		attributes('Main-Class': pluginMainClass, 'Multi-Release': true)
	}

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	from sourceSets.main.output
	from sourceSets.test.output
	from {
		configurations.testRuntimeClasspath.collect { file ->
			file.isDirectory() ? file : zipTree(file)
		}
	}

	exclude 'META-INF/INDEX.LIST'
	exclude 'META-INF/*.SF'
	exclude 'META-INF/*.DSA'
	exclude 'META-INF/*.RSA'
	exclude '**/module-info.class'

	group = BasePlugin.BUILD_GROUP
	archiveClassifier.set('shadow')
	archiveFileName.set("${rootProject.name}-${project.version}-all.jar")
}